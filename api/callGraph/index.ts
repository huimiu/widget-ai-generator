/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */

// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";

import { Context, HttpRequest } from "@azure/functions";
import { Client } from "@microsoft/microsoft-graph-client";
import { TokenCredentialAuthenticationProvider } from "@microsoft/microsoft-graph-client/authProviders/azureTokenCredentials";
import {
  ApiKeyLocation,
  ApiKeyProvider,
  AppCredential,
  AppCredentialAuthConfig,
  AxiosInstance,
  OnBehalfOfCredentialAuthConfig,
  OnBehalfOfUserCredential,
  createApiClient,
} from "@microsoft/teamsfx";

import config from "../config";

// Define a Response interface with a status number and a body object that can contain any key-value pairs.
interface Response {
  status: number;
  body: { [key: string]: any };
}

// Define a TeamsfxContext type as an object that can contain any key-value pairs.
type TeamsfxContext = { [key: string]: any };

// Define an enum called FilesType with four possible values for different types of Microsoft Office files.
enum FilesType {
  WORD = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  EXCEL = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  PPT = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  VISIO = "application/vnd.ms-visio.drawing",
}

/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 * Before trigger this function, teamsfx binding would process the SSO token and generate teamsfx configuration.
 *
 * This function initializes the teamsfx SDK with the configuration and calls these APIs:
 * - new OnBehalfOfUserCredential(accessToken, oboAuthConfig) - Construct OnBehalfOfUserCredential instance with the received SSO token and initialized configuration.
 * - getUserInfo() - Get the user's information from the received SSO token.
 * - createMicrosoftGraphClientWithCredential() - Get a graph client to access user's Microsoft 365 data.
 *
 * The response contains multiple message blocks constructed into a JSON object, including:
 * - An echo of the request body.
 * - The display name encoded in the SSO token.
 * - Current user's Microsoft 365 profile if the user has consented.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 */

/**
 * This function is the entry point for the Azure Function.
 * It handles HTTP requests from the Teams client and calls the appropriate function based on the request parameters.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 * @returns {Promise<Response>} - A promise that resolves with the HTTP response.
 */
export default async function run(
  context: Context,
  req: HttpRequest,
  teamsfxContext: TeamsfxContext
): Promise<Response> {
  context.log("HTTP trigger function processed a request.");

  // Initialize response.
  const res: Response = {
    status: 200,
    body: {},
  };

  // Put an echo into response body.
  res.body.receivedHTTPRequestBody = req.body || "";

  // Prepare access token.
  const accessToken: string = teamsfxContext["AccessToken"];
  if (!accessToken) {
    return {
      status: 400,
      body: {
        error: "No access token was found in request header.",
      },
    };
  }

  // Set up the configuration for the OnBehalfOfUserCredential.
  const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
    authorityHost: config.authorityHost,
    clientId: config.clientId,
    tenantId: config.tenantId,
    clientSecret: config.clientSecret,
  };

  let oboCredential: OnBehalfOfUserCredential;
  try {
    // Construct the OnBehalfOfUserCredential using the access token and configuration.
    oboCredential = new OnBehalfOfUserCredential(accessToken, oboAuthConfig);
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error:
          "Failed to construct OnBehalfOfUserCredential using your accessToken. " +
          "Ensure your function app is configured with the right Azure AD App registration.",
      },
    };
  }

  // Get the graphType, method, and request data from the HTTP request.
  const graphType = req.query["graphType"];
  const method = req.method;
  const reqData = req.body;

  try {
    // Call the appropriate function based on the graphType and method.
    const result = await handleRequest(
      oboCredential,
      graphType,
      method,
      reqData
    );
    res.body = { ...res.body, ...result };
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error: "Failed to process request.",
      },
    };
  }

  return res;
}

/**
 * Handles the request based on the given graphType and method.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {string} graphType - The type of graph to query (e.g. "calendar", "task").
 * @param {string} method - The HTTP method to use (e.g. "GET", "POST").
 * @param {any} reqData - The request data to use (if applicable).
 * @returns {Promise<any>} - A promise that resolves with the result of the request.
 */
async function handleRequest(
  oboCredential: OnBehalfOfUserCredential,
  graphType: string,
  method: string,
  reqData: any
): Promise<any> {
  // Switch statement to handle different graphType and method combinations
  switch (`${graphType}:${method}`) {
    // If graphType is "calendar" and method is "GET"
    case "calendar:GET": {
      // Call getCalendarEvents function to get calendar events
      const events = await getCalendarEvents(oboCredential);
      return { eventResult: events };
    }
    // If graphType is "task" and method is "GET"
    case "task:GET": {
      // Call getTasksInfo function to get task information
      const tasks = await getTasksInfo(oboCredential);
      return { taskResult: tasks };
    }
    // If graphType is "task" and method is "POST"
    case "task:POST": {
      // Call createTask function to create a new task
      const tasks = await createTask(oboCredential, reqData);
      return { taskResult: tasks };
    }
    // If graphType is "files" and method is "GET"
    case "files:GET": {
      // Call getFiles function to get files
      const files = await getFiles(oboCredential);
      return { filesResult: files };
    }
    // If graphType is "messages" and method is "GET"
    case "messages:GET": {
      // Call getChatMessages function to get chat messages
      const messages = await getChatMessages(oboCredential);
      return { messagesResult: messages };
    }
    // If no matching graphType and method combination is found
    default: {
      throw new Error(`Invalid graphType (${graphType}) or method (${method})`);
    }
  }
}

/**
 * Retrieves the user's calendar events for the current day.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of calendar events.
 */
async function getCalendarEvents(oboCredential: OnBehalfOfUserCredential) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Calendars.Read"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Set the end of the day to 23:59:59.999
  const endOfDay = new Date();
  endOfDay.setUTCHours(23, 59, 59, 999);

  // Get the user's calendar events for the current day
  const { value: calendarValue } = await graphClient
    .api(
      `/me/events?$top=2&$select=subject,bodyPreview,organizer,attendees,start,end,location,onlineMeeting&$filter=start/dateTime ge '${new Date().toUTCString()}' and start/dateTime lt '${endOfDay.toUTCString()}'`
    )
    .get();

  // Map the calendar events to a simpler format
  const calendarItems = calendarValue
    .map(({ start, end, subject, location, onlineMeeting }) => ({
      startTime: start,
      endTime: end,
      title: subject,
      location: location.displayName,
      url: onlineMeeting?.joinUrl,
    }))
    .reverse();

  return calendarItems;
}

/**
 * Retrieves the tasks that are not completed from the user's to-do list.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns {Promise<TaskModel[]>} - A promise that resolves with an array of tasks.
 */
async function getTasksInfo(oboCredential: OnBehalfOfUserCredential) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Tasks.ReadWrite"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Get the user's to-do lists
  const { value: tasklists } = await graphClient.api("/me/todo/lists").get();

  // Get the ID of the first to-do list
  const { id: todoTaskListId } = tasklists[0];

  // Get the tasks from the to-do list that are not completed and limit the results to 3
  const { value: tasksInfo } = await graphClient
    .api(
      `/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`
    )
    .get();

  // Map the tasks to a simpler format
  const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
    id,
    name: title,
    status,
    importance,
    content,
  }));

  return tasks;
}

/**
 * Creates a new task in the user's to-do list and retrieves the tasks that are not completed.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {any} reqData - The request data containing the task title.
 * @returns A promise that resolves with an array of tasks.
 */
async function createTask(
  oboCredential: OnBehalfOfUserCredential,
  reqData: any
) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Tasks.ReadWrite", "User.Read"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Get the user's to-do lists
  const { value: tasklists } = await graphClient.api("/me/todo/lists").get();

  // Get the ID of the first to-do list
  const { id: todoTaskListId } = tasklists[0];

  // Create a new task in the user's to-do list with the provided title
  await graphClient
    .api(`/me/todo/lists/${todoTaskListId}/tasks`)
    .post({ title: reqData.taskTitle });

  // Import the TeamsFx SDK and create a new instance for the app identity
  const authConfig: AppCredentialAuthConfig = {
    authorityHost: config.authorityHost,
    clientId: config.clientId,
    tenantId: config.tenantId,
    clientSecret: config.clientSecret,
  };
  const appCredential: AppCredential = new AppCredential(authConfig);

  // Send an activity notification to the user's Teams activity feed
  sendActivityNotification(appCredential, graphClient);

  // Get the tasks from the to-do list that are not completed and limit the results to 3
  const { value: tasksInfo } = await graphClient
    .api(
      `/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`
    )
    .get();

  // Map the tasks to a simpler format
  const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
    id,
    name: title,
    status,
    importance,
    content,
  }));

  return tasks;
}

/**
 * Sends an activity notification to the user's Teams activity feed.
 *
 * @param {TeamsFx} teamsfxApp - The TeamsFx instance for the app identity.
 * @param {Client} graphClient - The Microsoft Graph client.
 */
async function sendActivityNotification(
  appCredential: AppCredential,
  graphClient: Client
) {
  try {
    // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
    const authProvider = new TokenCredentialAuthenticationProvider(
      appCredential,
      {
        scopes: ["https://graph.microsoft.com/.default"],
      }
    );
    let appGraphClient: Client = Client.initWithMiddleware({
      authProvider: authProvider,
    });

    // Get user ID
    const userProfile = await graphClient.api("/me").get();
    const userId = userProfile["id"];

    // Construct the API path to retrieve the app installation information
    const apiPath = `/users/${userId}/teamwork/installedApps?$expand=teamsApp,teamsAppDefinition&$filter=teamsApp/externalId eq '${config.teamsAppId}'`;
    const appInstallationInfo = await appGraphClient.api(apiPath).get();

    // Extract the installation ID from the app installation info
    const appArray = appInstallationInfo["value"][0];
    const installationId = appArray["id"];

    // Create the post body for the activity notification
    let postbody = {
      topic: {
        source: "entityUrl",
        value: `https://graph.microsoft.com/v1.0/users/${userId}/teamwork/installedApps/${installationId}`,
      },
      activityType: "taskCreated",
      previewText: {
        content: "Task Created",
      },
    };

    // Send the activity notification to the user's Teams activity feed
    await appGraphClient
      .api("users/" + userId + "/teamwork/sendActivityNotification")
      .post(postbody);
  } catch (error) {
    console.error("sendActivityNotification error: ", error);
  }
}

/**
 * Retrieves the user's recently accessed files.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of files.
 */
async function getFiles(oboCredential: OnBehalfOfUserCredential) {
  // Create an instance of the TokenCredentialAuthenticationProvider by passing the tokenCredential instance and options to the constructor
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Calendars.Read"],
    }
  );

  // Initialize Graph client instance with authProvider
  const graphClient = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  // Get the user's recently accessed files
  const { value: driveInfo } = await graphClient
    .api(
      "/me/drive/recent?$top=5&$select=id,name,webUrl,createdBy,lastModifiedBy,remoteItem"
    )
    .get();

  // Map the files to a simpler format
  const returnAnswer = driveInfo.map(
    ({
      id,
      name,
      remoteItem: {
        createdBy,
        lastModifiedBy,
        createdDateTime,
        lastModifiedDateTime,
        file: { mimeType },
        webDavUrl,
        sharepointIds,
      },
      webUrl,
    }) => ({
      id,
      name,
      createdBy: createdBy.user.displayName,
      lastModifiedBy: lastModifiedBy.user.displayName,
      createdDateTime,
      lastModifiedDateTime,
      type: mimeType,
      weburl: webUrl,
      webDavurl: webDavUrl,
      teamsurl: generateTeamsUrl({
        webUrl,
        mimeType,
        webDavUrl,
        sharepointIds: sharepointIds.siteUrl,
      }),
    })
  );

  return returnAnswer;
}

async function getChatMessages(oboCredential: OnBehalfOfUserCredential) {
  const authProvider = new TokenCredentialAuthenticationProvider(
    oboCredential,
    {
      scopes: ["Chat.Read", "Chat.ReadWrite", "Chat.ReadBasic"],
    }
  );
  const client = Client.initWithMiddleware({
    authProvider: authProvider,
  });

  let chats = await client
    .api(
      "/me/chats?$filter=viewpoint/lastMessageReadDateTime ge 2023-08-08&$select=id,topic,chatType"
    )
    .get();

  // Get the chat IDs
  let chatIds = chats.value.map((chat: { id: any }) => chat.id);

  // Define a map to store the chat messages, keyed by chat ID, value is an array of messages
  let chatMessagesMap = new Map();

  // Get the messages from the chats
  for (let chatId of chatIds) {
    let messages = await client
      .api(
        `/chats/${chatId}/messages?$filter=lastModifiedDateTime gt 2023-08-08T00:00:00Z`
      )
      .get();

    // Filter yesterday messages and messageType is message
    let yesterdayMessages = messages.value.filter(
      (message: {
        createdDateTime: string;
        messageType: string;
        from: { user: object };
      }) => {
        if (message.messageType !== "message") {
          return false;
        }

        if (message.from.user == null) {
          return false;
        }

        let date = new Date(message.createdDateTime);
        let yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        let yesterdayStart = new Date(yesterday);
        yesterdayStart.setUTCHours(0, 0, 0, 0);
        let yesterdayEnd = new Date(yesterday);
        yesterdayEnd.setUTCHours(23, 59, 59, 999);
        return date > yesterdayStart && date < yesterdayEnd;
      }
    );

    // Extract createdDateTime, from/user/displayName, body/content from the messages
    let yesterdayMessagesInfo = yesterdayMessages.map(
      (message: {
        createdDateTime: string;
        from: { user: { displayName: any } };
        body: { content: any };
      }) => ({
        createdDateTime: message.createdDateTime,
        from: message.from.user?.displayName,
        content: message.body.content,
      })
    );
    chatMessagesMap.set(chatId, yesterdayMessagesInfo);
  }

  return chatMessagesMap;
}

async function callOAI(body: string) {
  try {
    const completionReq = {
      prompt: `<|im_start|>system\nYou are an AI assistant that helps people find information.\n<|im_end|>\n<|im_start|>user\n${body}\n<|im_end|>\n<|im_start|>assistant`,
      max_tokens: 4096,
      temperature: 0.9,
      stop: ["<|im_end|>"],
    };

    const authProvider = new ApiKeyProvider(
      "api-key",
      process.env.TEAMSFX_API_OAI_API_KEY,
      ApiKeyLocation.Header
    );
    const apiClient: AxiosInstance = createApiClient(
      process.env.TEAMSFX_API_OAI_ENDPOINT,
      authProvider
    );
    const resp = await apiClient.post(
      "/chat/completions?api-version=2023-05-15",
      completionReq
    );
    if (resp.status !== 200) {
      return {
        status: resp.status,
        body: resp.data,
      };
    }

    const response = resp.data.choices[0].text;
    return response;
  } catch (e) {
    console.error(e);
    return {
      status: 500,
      body: e,
    };
  }
}

/**
 * Generates a Teams URL for a file.
 *
 * @param {Object} param0 - The file information.
 * @returns {string} - The Teams URL.
 */
function generateTeamsUrl({
  webUrl,
  mimeType,
  webDavUrl,
  sharepointIds,
}): string {
  let url = "https://teams.microsoft.com/l/file/";

  // Get the file ID from the web URL
  const fileIdStartIndex = webUrl.indexOf("sourcedoc=%7B") + 13;
  const fileIdEndIndex = webUrl.indexOf("%7D");
  const fileId = webUrl.substring(fileIdStartIndex, fileIdEndIndex);
  url += fileId + "?";

  // Get the file type from the MIME type
  let fileTypeString = "";
  switch (mimeType) {
    case FilesType.WORD:
      fileTypeString = "docx";
      break;
    case FilesType.EXCEL:
      fileTypeString = "xlsx";
      break;
    case FilesType.PPT:
      fileTypeString = "pptx";
      break;
    case FilesType.VISIO:
      fileTypeString = "vsd";
      break;
    default:
      fileTypeString = mimeType.substring(
        mimeType.indexOf("application/" + 12)
      );
      break;
  }
  url += "fileType=" + fileTypeString;

  // Encode the object URL and add it to the URL
  const encodedObjectURL = webDavUrl.replace(/:/g, "%3A").replace(/\//g, "%2F");
  url += "&objectUrl=" + encodedObjectURL;

  // Encode the base URL and add it to the URL
  const encodedBaseUrl = sharepointIds
    .replace(/:/g, "%3A")
    .replace(/\//g, "%2F");
  url += "&baseUrl=" + encodedBaseUrl;

  return url;
}
